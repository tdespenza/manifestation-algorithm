name: Publish Release

# Triggered directly when the Auto-Merge Dev to Main workflow completes
# successfully. Using workflow_run is the only reliable way to chain off a
# bot-authenticated merge — tag-push triggers are frequently suppressed by
# GitHub when the push originates from a workflow token.
on:
  workflow_run:
    workflows: ['Auto-Merge Dev to Main']
    types: [completed]

permissions:
  contents: write

jobs:
  # ─────────────────────────────────────────────────────────────────────────
  # DESIGN: tauri-action is used ONLY to build — no release-management inputs
  # (releaseId / tagName / releaseName) are passed, so it never touches GitHub
  # Releases.  Built installers are stashed in GitHub Actions artifact storage
  # and collected by the release job below, which creates the release
  # atomically with all files already present.  This eliminates the entire
  # class of "immutable release" / draft-publish race errors.
  # ─────────────────────────────────────────────────────────────────────────

  # ── 1. Resolve the version tag ────────────────────────────────────────────
  resolve-tag:
    name: Resolve Version Tag
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout Main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Read Version from package.json
        id: version
        run: echo "tag=v$(jq -r .version package.json)" >> "$GITHUB_OUTPUT"

  # ── 2. Build all three platforms in parallel ──────────────────────────────
  build:
    name: Build (${{ matrix.name }})
    needs: resolve-tag
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            name: Linux
            rust_target: ""
            tauri_args: ""
            artifact-paths: |
              src-tauri/target/release/bundle/appimage/*.AppImage
              src-tauri/target/release/bundle/appimage/*.AppImage.sig
          - os: windows-latest
            name: Windows
            rust_target: ""
            tauri_args: ""
            artifact-paths: |
              src-tauri/target/release/bundle/msi/*.msi
              src-tauri/target/release/bundle/msi/*.msi.zip
              src-tauri/target/release/bundle/msi/*.msi.zip.sig
              src-tauri/target/release/bundle/nsis/*.exe
              src-tauri/target/release/bundle/nsis/*.nsis.zip
              src-tauri/target/release/bundle/nsis/*.nsis.zip.sig
          - os: macos-latest
            name: macOS-Apple-Silicon
            rust_target: aarch64-apple-darwin
            tauri_args: --target aarch64-apple-darwin
            artifact-paths: |
              src-tauri/target/aarch64-apple-darwin/release/bundle/dmg/*.dmg
              src-tauri/target/aarch64-apple-darwin/release/bundle/macos/*.app.tar.gz
              src-tauri/target/aarch64-apple-darwin/release/bundle/macos/*.app.tar.gz.sig
          - os: macos-14
            name: macOS-Intel
            rust_target: x86_64-apple-darwin
            tauri_args: --target x86_64-apple-darwin
            artifact-paths: |
              src-tauri/target/x86_64-apple-darwin/release/bundle/dmg/*.dmg
              src-tauri/target/x86_64-apple-darwin/release/bundle/macos/*.app.tar.gz
              src-tauri/target/x86_64-apple-darwin/release/bundle/macos/*.app.tar.gz.sig

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout Main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Set Up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Set Up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust Dependencies
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install Linux System Dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libgtk-3-dev \
            libssl-dev \
            libsoup-3.0-dev \
            pkg-config

      - name: Install Dependencies
        run: npm ci

      - name: Add Rust Target
        if: ${{ matrix.rust_target != '' }}
        run: rustup target add ${{ matrix.rust_target }}

      - name: Build
        uses: tauri-apps/tauri-action@v0
        # No releaseId / tagName / releaseName — build only, no release management.
        with:
          args: ${{ matrix.tauri_args }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Upload Installers to Actions Artifact Storage
        uses: actions/upload-artifact@v4
        with:
          name: installers-${{ matrix.name }}
          path: ${{ matrix.artifact-paths }}
          # warn (not error) so a failed build doesn't block the other platforms
          # from uploading and doesn't prevent the release job from running.
          if-no-files-found: warn
          retention-days: 1

  # ── 3. Create release and upload all installers in one atomic step ────────
  # Runs after every platform build completes (success or failure).  Only the
  # artifacts from successful builds are uploaded.  If every build failed the
  # job exits early without creating a release.
  release:
    name: Create Release
    needs: [resolve-tag, build]
    # always() lets this job run even when some build matrix entries failed.
    # We still require resolve-tag to have succeeded and at least one build
    # to have run (result is 'success' or 'failure', never 'skipped').
    if: |
      always() &&
      needs.resolve-tag.result == 'success' &&
      (needs.build.result == 'success' || needs.build.result == 'failure')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout Main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Generate Release Notes
        id: notes
        uses: orhun/git-cliff-action@v4
        with:
          config: cliff.toml
          args: --latest --strip all
        env:
          OUTPUT: /tmp/release-notes.txt
          GITHUB_REPO: ${{ github.repository }}

      - name: Download All Installer Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: installers-*
          path: dist
          merge-multiple: true

      - name: List Downloaded Files
        run: find dist -type f | sort

      - name: Check Whether Any Artifacts Were Downloaded
        id: guard
        run: |
          count=$(find dist -type f 2>/dev/null | wc -l | tr -d ' ')
          if [ "$count" -eq 0 ]; then
            echo "::warning::No installer artifacts from any build — skipping release creation."
            echo "has_files=false" >> "$GITHUB_OUTPUT"
          else
            echo "$count installer file(s) ready for release."
            echo "has_files=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Delete Existing Release for This Tag
        if: steps.guard.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Only delete the GitHub Release — do NOT delete the git tag.
          # The tag was already created and pushed by the auto-merge workflow.
          # Deleting the tag and trying to recreate it would hit repository
          # ruleset restrictions ("Cannot create ref due to creations being
          # restricted"). gh release create with a pre-existing tag simply
          # attaches the new release to it without touching the tag ref.
          gh release delete "${{ needs.resolve-tag.outputs.tag }}" \
            --repo "${{ github.repository }}" \
            --yes 2>/dev/null || true

      - name: Create and Publish Release with All Installers
        if: steps.guard.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.resolve-tag.outputs.tag }}"
          PRERELEASE_FLAG=""
          if echo "$TAG" | grep -q '-'; then
            PRERELEASE_FLAG="--prerelease"
          fi

          # Create the release without assets first.
          # Assets are uploaded separately via xargs -0 so that filenames
          # containing spaces (e.g. "Manifestation Algorithm_0.1.0.dmg")
          # are handled correctly — $(find …) word-splits on spaces.
          gh release create "$TAG" \
            --repo "${{ github.repository }}" \
            --title "Manifestation Algorithm $TAG" \
            --notes-file /tmp/release-notes.txt \
            $PRERELEASE_FLAG

          find dist -type f -print0 | xargs -0 gh release upload "$TAG" \
            --repo "${{ github.repository }}"

      - name: Generate latest.json for In-App Updater
        if: steps.guard.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PAT: ${{ secrets.PAT }}
        run: |
          TAG="${{ needs.resolve-tag.outputs.tag }}"
          VERSION="${TAG#v}"
          PUB_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          REPO="${{ github.repository }}"
          BASE_URL="https://github.com/${REPO}/releases/download/${TAG}"

          # Build the updater feed from whatever signed artifacts actually exist.
          # Tauri expects a per-platform URL + detached signature.
          TAG="$TAG" VERSION="$VERSION" PUB_DATE="$PUB_DATE" BASE_URL="$BASE_URL" python3 - <<'PY'
          import json
          import os
          import pathlib
          import sys

          dist = pathlib.Path('dist')
          notes_path = pathlib.Path('/tmp/release-notes.txt')

          tag = os.environ['TAG']
          version = os.environ['VERSION']
          pub_date = os.environ['PUB_DATE']
          base_url = os.environ['BASE_URL'].rstrip('/')

          notes = notes_path.read_text().strip() if notes_path.exists() else ''

          def iter_files(suffix: str):
            if not dist.exists():
              return []
            return sorted([p for p in dist.rglob(f'*{suffix}') if p.is_file()])

          def pick_signed_asset(preferred_suffixes: list[str], path_hint_tokens: list[str] | None = None):
            """Return (asset_path, signature_text) or (None, None)."""
            if path_hint_tokens is None:
              path_hint_tokens = []
            for suffix in preferred_suffixes:
              candidates = [p for p in iter_files(suffix) if not str(p).endswith('.sig')]
              if path_hint_tokens:
                hinted = [p for p in candidates if any(tok in str(p) for tok in path_hint_tokens)]
                if hinted:
                  candidates = hinted
              for asset in candidates:
                sig = asset.with_name(asset.name + '.sig')
                if sig.exists() and sig.is_file():
                  sig_text = sig.read_text().strip()
                  if sig_text:
                    return asset, sig_text
            return None, None

          platforms: dict[str, dict[str, str]] = {}

          # Linux: AppImage (preferred)
          linux_asset, linux_sig = pick_signed_asset(['.AppImage'])
          if linux_asset:
            platforms['linux-x86_64'] = {
              'signature': linux_sig,
              'url': f"{base_url}/{linux_asset.name}",
            }

          # Windows: prefer MSI zip, fall back to NSIS zip, then raw EXE
          win_asset, win_sig = pick_signed_asset(['.msi.zip', '.nsis.zip', '.exe'])
          if win_asset:
            platforms['windows-x86_64'] = {
              'signature': win_sig,
              'url': f"{base_url}/{win_asset.name}",
            }

          # macOS: separate builds per arch (aarch64 + x86_64)
          mac_arm_asset, mac_arm_sig = pick_signed_asset(
            ['.app.tar.gz'],
            path_hint_tokens=['aarch64-apple-darwin', 'darwin-aarch64', 'aarch64'],
          )
          if mac_arm_asset:
            platforms['darwin-aarch64'] = {
              'signature': mac_arm_sig,
              'url': f"{base_url}/{mac_arm_asset.name}",
            }

          mac_x64_asset, mac_x64_sig = pick_signed_asset(
            ['.app.tar.gz'],
            path_hint_tokens=['x86_64-apple-darwin', 'darwin-x86_64', 'x86_64'],
          )
          if mac_x64_asset:
            platforms['darwin-x86_64'] = {
              'signature': mac_x64_sig,
              'url': f"{base_url}/{mac_x64_asset.name}",
            }

          if not platforms:
            print('::warning::No updater artifacts detected in dist/ (missing .sig files or unsupported filenames). Skipping latest.json generation.')
            # Write a sentinel so the shell knows to skip the git commit.
            pathlib.Path('/tmp/skip_latest_json').touch()
            sys.exit(0)

          data = {
            'version': version,
            'notes': notes,
            'pub_date': pub_date,
            'platforms': platforms,
          }

          out = pathlib.Path('website/latest.json')
          out.parent.mkdir(parents=True, exist_ok=True)
          out.write_text(json.dumps(data, indent=2) + '\n')
          print('Generated website/latest.json:')
          print(json.dumps(data, indent=2))
          PY

          # Commit latest.json to main so the pages deployment picks it up.
          # Skip entirely if the Python script found no signed artifacts.
          if [ -f /tmp/skip_latest_json ]; then
            echo "No signed updater artifacts — skipping latest.json commit."
            exit 0
          fi
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PAT}@github.com/${REPO}"
          git add website/latest.json
          git diff --cached --quiet || git commit -m "chore: update latest.json for v${VERSION} [skip ci]"
          git push origin main

