name: Publish Release

# Triggered directly when the Auto-Merge Dev to Main workflow completes
# successfully. Using workflow_run is the only reliable way to chain off a
# bot-authenticated merge — tag-push triggers are frequently suppressed by
# GitHub when the push originates from a workflow token.
on:
  workflow_run:
    workflows: ['Auto-Merge Dev to Main']
    types: [completed]

permissions:
  contents: write

jobs:
  # ─────────────────────────────────────────────────────────────────────────
  # DESIGN: tauri-action is used ONLY to build — no release-management inputs
  # (releaseId / tagName / releaseName) are passed, so it never touches GitHub
  # Releases.  Built installers are stashed in GitHub Actions artifact storage
  # and collected by the release job below, which creates the release
  # atomically with all files already present.  This eliminates the entire
  # class of "immutable release" / draft-publish race errors.
  # ─────────────────────────────────────────────────────────────────────────

  # ── 1. Resolve the version tag ────────────────────────────────────────────
  resolve-tag:
    name: Resolve Version Tag
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Read version from package.json
        id: version
        run: echo "tag=v$(jq -r .version package.json)" >> "$GITHUB_OUTPUT"

  # ── 2. Build all three platforms in parallel ──────────────────────────────
  build:
    name: Build (${{ matrix.name }})
    needs: resolve-tag
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            name: Linux
            rust_target: ""
            tauri_args: ""
            artifact-paths: |
              src-tauri/target/release/bundle/deb/*.deb
              src-tauri/target/release/bundle/appimage/*.AppImage
          - os: windows-latest
            name: Windows
            rust_target: ""
            tauri_args: ""
            artifact-paths: |
              src-tauri/target/release/bundle/msi/*.msi
              src-tauri/target/release/bundle/nsis/*.exe
          - os: macos-latest
            name: macOS-Apple-Silicon
            rust_target: aarch64-apple-darwin
            tauri_args: --target aarch64-apple-darwin
            artifact-paths: |
              src-tauri/target/aarch64-apple-darwin/release/bundle/dmg/*.dmg
              src-tauri/target/aarch64-apple-darwin/release/bundle/macos/*.app.tar.gz
          - os: macos-14
            name: macOS-Intel
            rust_target: x86_64-apple-darwin
            tauri_args: --target x86_64-apple-darwin
            artifact-paths: |
              src-tauri/target/x86_64-apple-darwin/release/bundle/dmg/*.dmg
              src-tauri/target/x86_64-apple-darwin/release/bundle/macos/*.app.tar.gz

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Set Up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Set Up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust Dependencies
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install Linux System Dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libgtk-3-dev \
            libssl-dev \
            libsoup-3.0-dev \
            pkg-config

      - name: Install Dependencies
        run: npm ci

      - name: Add Rust target
        if: ${{ matrix.rust_target != '' }}
        run: rustup target add ${{ matrix.rust_target }}

      - name: Build
        uses: tauri-apps/tauri-action@v0
        # No releaseId / tagName / releaseName — build only, no release management.
        with:
          args: ${{ matrix.tauri_args }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Upload installers to Actions artifact storage
        uses: actions/upload-artifact@v4
        with:
          name: installers-${{ matrix.name }}
          path: ${{ matrix.artifact-paths }}
          # warn (not error) so a failed build doesn't block the other platforms
          # from uploading and doesn't prevent the release job from running.
          if-no-files-found: warn
          retention-days: 1

  # ── 3. Create release and upload all installers in one atomic step ────────
  # Runs after every platform build completes (success or failure).  Only the
  # artifacts from successful builds are uploaded.  If every build failed the
  # job exits early without creating a release.
  release:
    name: Publish Release
    needs: [resolve-tag, build]
    # always() lets this job run even when some build matrix entries failed.
    # We still require resolve-tag to have succeeded and at least one build
    # to have run (result is 'success' or 'failure', never 'skipped').
    if: |
      always() &&
      needs.resolve-tag.result == 'success' &&
      (needs.build.result == 'success' || needs.build.result == 'failure')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Generate Release Notes
        id: notes
        uses: orhun/git-cliff-action@v4
        with:
          config: cliff.toml
          args: --latest --strip all
        env:
          OUTPUT: /tmp/release-notes.txt
          GITHUB_REPO: ${{ github.repository }}

      - name: Download all installer artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: installers-*
          path: dist
          merge-multiple: true

      - name: List downloaded files
        run: find dist -type f | sort

      - name: Check whether any artifacts were downloaded
        id: guard
        run: |
          count=$(find dist -type f 2>/dev/null | wc -l | tr -d ' ')
          if [ "$count" -eq 0 ]; then
            echo "::warning::No installer artifacts from any build — skipping release creation."
            echo "has_files=false" >> "$GITHUB_OUTPUT"
          else
            echo "$count installer file(s) ready for release."
            echo "has_files=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Delete any existing release for this tag
        if: steps.guard.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Only delete the GitHub Release — do NOT delete the git tag.
          # The tag was already created and pushed by the auto-merge workflow.
          # Deleting the tag and trying to recreate it would hit repository
          # ruleset restrictions ("Cannot create ref due to creations being
          # restricted"). gh release create with a pre-existing tag simply
          # attaches the new release to it without touching the tag ref.
          gh release delete "${{ needs.resolve-tag.outputs.tag }}" \
            --repo "${{ github.repository }}" \
            --yes 2>/dev/null || true

      - name: Create and publish release with all installers
        if: steps.guard.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.resolve-tag.outputs.tag }}"
          PRERELEASE_FLAG=""
          if echo "$TAG" | grep -q '-'; then
            PRERELEASE_FLAG="--prerelease"
          fi

          # Create the release without assets first.
          # Assets are uploaded separately via xargs -0 so that filenames
          # containing spaces (e.g. "Manifestation Algorithm_0.1.0.dmg")
          # are handled correctly — $(find …) word-splits on spaces.
          gh release create "$TAG" \
            --repo "${{ github.repository }}" \
            --title "Manifestation Algorithm $TAG" \
            --notes-file /tmp/release-notes.txt \
            $PRERELEASE_FLAG

          find dist -type f -print0 | xargs -0 gh release upload "$TAG" \
            --repo "${{ github.repository }}"

